<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Les fonctions</title>
</head>
<body>
    <!-- https://www.pierre-giraud.com/javascript-apprendre-coder-cours/fonction-flechee/ -->
    <h1>Les déclarations de fonctions</h1>
    <p>function disBonjour() { <br>
        alert('Bonjour'); <br>
    }</p>

    <h1>Les expressions de fonctions</h1>
    <p>Pour créer une expression de fonction, nous allons utiliser une syntaxe similaire à celle-ci-dessus à la différence qu'on va cette fois-ci directement assigner notre fonction à une variable dont on choisira le nom.</p>
    <p>let disBonjour = function() { <br>
    alert('Bonjour'); <br>
    } <br>
    disBonjour();</p> <!-- Appel de la variable/fonction -->

    <p>Généralement, lorsqu’on crée une fonction de cette manière, on utilise une fonction anonyme qu’on assigne ensuite à une variable. Pour appeler une fonction créée comme cela, on va pouvoir utiliser la variable comme une fonction, c’est-à-dire avec un couple de parenthèses après son nom.

    Notez cependant que rien ne nous empêche cependant de donner un nom à notre fonction. Dans ce cas-là, on parlera de « NFE » pour « Named Function Expression » ou « expression de fonction nommée » en français.
        
    Ajouter un nom à une expression de fonction permet à la fonction de faire référence à elle-même en interne en étant sûr de s’appeler. En effet, en utilisant une expression de fonction classique, la variable qui contient l’expression de fonction peut changer de valeur dans le script et rendre notre fonction inutilisable.</p>
    <p>let disBonjour = function bonjour(nom) { <br>
        if(nom) { <br>
            alert('Bonjour ' + nom); <br>
        } else { <br>
            bonjour('inconnu'); <br>
        } <br>
    }</p>

    <p>De plus, le nom passé aux NFE n'est pas accessible depuis l'extérieur de la fonction. Cel garantit qu'en l'utilisant dans notre expression de fonction, il fera toujours bien référence à la fonction actuelle.</p>

    <h1>Déclarations de fonctions VS expressions de fonctions</h1>
    <p>Dans la grande majorité des cas, il est plus pratique d’utiliser une déclaration de fonction qu’une expression de fonction pour créer une fonction en JavaScript. En effet, lorsqu’on crée des fonctions en utilisant des déclarations de fonctions, celles-ci vont être immédiatement disponibles dans le script ou dans l’espace dans lequel elles ont été créées, ce qui n’est pas le cas pour les expressions de fonctions. <br>

    Cela est dû au fait que les déclarations de fonctions sont les premiers éléments recherchés et lus par le JavaScript lorsqu’un script est exécuté. Les expressions de fonctions, au contraire, vont être lues dans l’ordre de leur écriture dans le script.</p>

    <p>disBonjour(); // Ceci fonctionne <br>

    function disBonjour(){ <br>
        alert('Bonjour'); <br>
    } <br>
    
    disAuRevoir(); // Ceci ne fonctionne pas <br>
    
    let disAuRevoir = function(){ <br>
        alert('Au revoir'); <br>
    }</p>

    <h1>Les expressions de fonctions fléchées : syntaxe et intérêts</h1>
    <p>Les fonctions fléchées sont des fonctions qui possèdent une syntaxe très compacte, ce qui les rend très rapide à écrire. Les fonctions fléchées utilisent le signe <strong>=></strong> qui leur a donné leur nom à cause de sa forme de flèche.</p>
    <p><strong>Expression de fonction classique :</strong> <br>
    let somme = function(a, b) { <br>
        return a + b; <br>
    }; <br>
    
    <strong>Equivalent en fonction fléchée :</strong> <br>
    let somme = (a, b) => a + b; <br>
    
    alert(somme(1, 2));</p>

    <p>La syntaxe des fonctions fléchées et très concise et cela est normal puisque ce sont des fonctions qui ont été faites pour être déclarées sur une seule et unique ligne. <br>

    Les fonctions fléchées n’ont pas besoin du couple d’accolades classique aux fonctions pour fonctionner et n’ont pas besoin non plus d’une expression <strong>return</strong> puisque celles-ci vont automatiquement évaluer l’expression à droite du signe <strong>=></strong> et retourner son résultat. <br>
    
    De plus, notez que si notre fonction fléchée n’a besoin que d’un argument pour fonctionner, alors on pourra également omettre le couple de parenthèses.</p>

    <p><strong>Expression de fonction classique :</strong> <br>
    let double = function(n){ <br>
        return n * 2 <br>
    } <br>
    
    <strong>Equivalent en fonction fléchée :</strong> <br>
    let double = n => n * 2; <br>
    
    alert(double(3)); <br> </p>

    <p>Tout cela est vrai pour des fonctions fléchées déclarées sur une ligne. On va également pouvoir déclarer des fonctions fléchées sur plusieurs lignes, mais nous allons alors perdre beaucoup des avantages offerts par celles-ci en termes de concision du code. En effet, lorsqu’on écrit une fonction fléchée sur plusieurs lignes, alors notre fonction va à nouveau avoir besoin du traditionnel couple d’accolades ainsi qu’on précise explicitement une instruction <strong>return</strong> dans le cas où l’on souhaite que la fonction retourne une valeur.</p>

    <h1>Les particularités des fonctions fléchées</h1>
    <p>En plus de leur syntaxe très compacte, les fonctions fléchées vont posséder certains comportements différents des fonctions classiques.</p>
    <p>Les comportements intéressants à noter ici sont que les fonctions fléchées ne possèdent pas de valeur pour <strong>this</strong> ni pour l’objet <strong>arguments</strong>.</p>

    <h2>Les fonctions fléchées et le mot clé <strong>this</strong></h2>
    <p>Pour rappel, le mot clé <strong>this</strong> est utilisé avec des méthodes d’un d’objet pour accéder à des informations stockées dans l’objet. Le mot clé this va dans ce cas être substitué par l’objet utilisant la méthode lors de son appel.</p>

    <p>let pierre = { <br>
        nom: 'Giraud', <br>
        prenom: 'Pierre', <br>
        hobbies: ['Trail', 'Triathlon', 'Cuisine'], <br>
      
        getFullName(){ <br>
            alert(this.prenom + ' ' + this.nom); <br>
        } <br>
    }; <br>
    pierre.getFullName(); <br></p>

    <p>En JavaScript, à la différence de la plupart des langages, le mot clé <strong>this</strong> n’est pas lié à un objet en particulier. En effet, la valeur de <strong>this</strong> va être évaluée au moment de l’appel de la méthode dans laquelle il est présent en JavaScript. <br>
    Ainsi, la valeur de <strong>this</strong> ne va pas dépendre de l’endroit où la méthode a été déclarée mais de l’objet qui l’appelle. Cela permet notamment à une méthode d’être réutilisée par différents objets. <br>
    Comme la valeur de <strong>this</strong> ne dépend pas de l’endroit où la méthode a été déclarée, on va en fait pouvoir utiliser ce mot clé dans n’importe quelle fonction.</p>

    <p>let pierre = {name: 'Pierre'}; <br>
        let mathilde = {name: 'Mathilde'}; <br>
        
        function disBonjour(){ <br>
          alert('Bonjour ' + this.name); <br>
        } <br>
        
        pierre.bonjour = disBonjour; <br>
        mathilde.bonjour = disBonjour; <br>
        
        pierre.bonjour(); //Bonjour Pierre <br>
        mathilde.bonjour(); //Bonjour Mathilde</p>

    <p>Les fonctions fléchées, cependant, sont différentes des autres fonctions au sens où elles ne possèdent pas de valeur propre pour <strong>this</strong> : si on utilise ce mot clé dans une fonction fléchée, alors la valeur utilisée pour celui-ci sera celle du contexte de la fonction fléchée c’est-à-dire celle de la fonction englobante.</p>

    <p>let pierre = { <br>
        nom: 'Giraud', <br>
        prenom: 'Pierre', <br>
        hobbies: ['Trail', 'Triathlon', 'Cuisine'], <br>
      
        disBonjour(){ <br>
            let bonjour = () => alert('Bonjour ' + this.prenom); <br>
            bonjour(); <br>
        } <br>
    }; <br>
    
    pierre.disBonjour(); //Bonjour Pierre</p>

    <h2>Les fonctions fléchées et l'objet arguments</h2>
    <p>L’objet <strong>arguments</strong> est un objet qui recense les différents arguments passés à une fonction. Cet objet est une propriété disponible dans toutes les fonctions à l’exception des fonctions fléchées.

    L’objet <strong>arguments</strong> est semblable à un tableau et contient une entrée pour chaque argument passé à la fonction, l’indice de la première entrée commençant à 0.
        
    Aujourd’hui, on préfèrera cependant manipuler les arguments en utilisant les paramètres du reste plutôt que cet objet tant que possible.</p>
    
    <script>
        // function canDrive (age, pays) {
        //     if(
        //         (pays === 'FR' && age >= 18) ||
        //         (pays === 'US' && age >= 16)
        //     ) {
        //         return true
        //     }
        //     return false
        // }

        // const canDrive = function (age, pays) {
        //     if(
        //         (pays === 'FR' && age >= 18) ||
        //         (pays === 'US' && age >= 16)
        //     ) {
        //         return true
        //     }
        //     return false
        // }
        // console.log(canDrive(19, 'FR'))

        // fonction utilisant this
        // const a = {
        //     firstname: 'John',
        //     lastname: 'Doe',
        //     fullname: function() {
        //         console.log(`${this.firstname} ${this.lastname}`)
        //     }
        // }
        // a.fullname()
        // console.log('Hello'.toUpperCase())

        // fonction fléchée
        // const maFonction = (param1, param2) => {
        //     console.log(param1, param2)
        // }
        // maFonction(1, 2)


        // EXERCICE 1
        // on crée un nombre entre 0 et 10
        // 3 essais pour deviner le nombre
        // fonction isRight(n)
        // guess()
        // function getRandomInt(max) {
        //     return Math.floor(Math.random() * (max +1))
        // }

        // const solution = getRandomInt(10)
        //  console.log(solution)

        // function isRight(n) {
        //     return solution === n
        // }

        // function guess() {
        //     const number = prompt('Entrer un chiffre') * 1
        //     return isRight(number)
        // }

        // for(i = 0; i < 3; i++) {
        //     if(guess()) {
        //         console.log('Bravo');
        //         break;
        //     } else if(i === 2) {
        //         console.log('Vous avez perdu')
        //     }
        // }


        // EXERCICE 2
        // dire si un nombre est premier ou non
        // function isPremier(n) {
        //     if(n < 2) {
        //         return false
        //     }
        //     for(let i = n -1; i > 1; i--) {
        //         // console.log(i) 
        //         if(n % i === 0) {
        //             return false;
        //         };
        //     }
        //     return true
        // }

        // console.log('0', isPremier(0))
        // console.log('1', isPremier(1))
        // console.log('2', isPremier(2))
        // console.log('3', isPremier(3))
        // console.log('11', isPremier(11))
        // console.log('12', isPremier(12))


        // // EXERCICE 3
        // // savoir si un mot est un palindrome
        // function isPalindrome(str) {
        //     // reverse (ne prend en paramètre que des tableaux)
        //     // split
        //     // join
        //     // toUpperCase
        //     // const letters = str.split('');
        //     // letters.reverse();
        //     // const reversedWord = letters.join('');
        //     // return str.toUpperCase() === reversedWord.toUpperCase();
            
        //     // OU
        //     const letters = str // on a un mot
        //         .split('') // que l'on explose en tableau
        //         .reverse() // tableau que l'on inverse
        //         .join(''); // tableau inversé que l'on rejoint par des guillemets
        //     return str.toUpperCase() === letters.toUpperCase();
            
        //     // console.log(letters);
        //     // console.log(reversedWord);

        // }

        // const words = {
        //     kayak: true,
        //     SOS: true,
        //     Kayak: true,
        //     Bonjour: false,
        // }
        // for(let word in words) {
        //     // if(isPalindrome(word) !== words[word]) {
        //     //     console.error(`isPalindrome(${word}) aurait dû renvoyer ${words[word]}`)
        //     // } else {
        //     //     console.log(`isPalindrome(${word}) return ${isPalindrome(word)} et renvoie bien ${words[word]}`)
        //     // }

        //     if(isPalindrome(word)) {
        //         console.log(`${word} est un palindrome`)
        //     } else {
        //         console.log(`${word} n'est pas un palindrome`)
        //     }
        // }

        


        // EXERCICE 4
        // calculer la moyenne qu'à chacun des élèves
        // transformer l'objet pour ajouter une propriété moyenne à chacun des élèves qui contiendrait la moyenne des notes
        // on organise les élèves en fonction de la moyenne la plus élevée
        // on affiche en console un top 3 des élèves

        // const students = [
        //     {
        //         name: 'John',
        //         notes: [1, 20, 18, 19, 12]
        //     },
        //     {
        //         name: 'Jane',
        //         notes: [17, 18, 20, 13, 15]
        //     },
        //     {
        //         name: 'Sophie',
        //         notes: [17, 12, 14, 15, 13]
        //     },
        //     {
        //         name: 'Marc',
        //         notes: [2, 3, 5, 8, 9]
        //     },
        //     {
        //         name: 'Manon',
        //         notes: [18, 17, 18, 19, 12]
        //     }
        // ]

        // const moyenne = (notes) => {
        //     let sum = 0;
        //     for(let note of notes) {
        //         sum = sum + note;
        //     }
        //     //console.log(sum / notes.length);
        //     return sum / notes.length;
        // }
        // //moyenne([10, 20])

        // const compareStudent = (a, b) => {
        //     return b.moyenne - a.moyenne  // si b > a, donnera qch de négatif ; si a > b, donnera qch de positif
        // }

        // for(let student of students) {
        //     student.moyenne = moyenne(student.notes);
        //     student.worst = Math.min(...student.notes);
        //     student.best = Math.max(...student.notes)
        // }

        // // pour afficher le top 3 des meilleurs élèves
        // const formatStudent = (student) => {
        //     return `${student.name} avec une moyenne de ${student.moyenne}, la meilleure note étant ${student.best} et la pire ${student.worst}.`
        // }

        // students.sort(compareStudent)
        // console.log(students)

        // // Répétition de code, donc création d'une fonction 'formatStudent'
        // // console.log(`Top 3 des étudiants
        // // 1: ${students[0].name} avec une moyenne de ${students[0].moyenne},
        // // 2: ${students[1].name} avec une moyenne de ${students[1].moyenne},
        // // 3: ${students[2].name} avec une moyenne de ${students[2].moyenne}`)

        // console.log(`Top 3 des étudiants :
        // 1: ${formatStudent(students[0])},
        // 2: ${formatStudent(students[1])},
        // 3: ${formatStudent(students[2])}`)

        // EXERCICE 5
        // calculer la fréquence de mot dans une chaîne de caractère
        const phrase = `Vous savez, moi je ne crois pas qu'il y ait de bonne ou de mauvaise situation. Moi, si je devais résumer ma vie aujourd'hui avec vous, je dirais que c'est d'abord des rencontres. Des gens qui m'ont tendu la main, peut-être à un moment où je ne pouvais pas, où j'étais seul chez moi. Et c'est assez curieux de se dire que les hasards, les rencontres, forgent une destinée... Parce que quand on a le goût de la chose, quand on a le goût de la chose bien faite, le beau geste, parfois on ne trouve pas l'interlocuteur en face je dirais, le miroir qui vous aide à avancer. Alors ça n'est pas mon cas, comme je disais là, puisque moi au contraire, j'ai pu : et je dis merci à la vie, je lui dis merci, je chante la vie, je danse la vie... je ne suis qu'amour ! Et finalement, quand beaucoup de gens aujourd'hui me disent « Mais comment fais-tu pour avoir cette humanité ? », et bien je leur réponds très simplement, je leur dis que c'est ce goût de l'amour ce goût donc qui m'a poussé aujourd'hui à entreprendre une construction mécanique, mais demain qui sait ? Peut-être simplement à me mettre au service de la communauté, à faire le don, le don de soi...`;

        const frequencies = {};
        const ignored = [',', ';', '!', '?', '.', '...', ':', '«', '»']
        let cleanedPhrase = phrase.toLowerCase()
        for(let character of ignored) {
           cleanedPhrase = cleanedPhrase.replaceAll(character, '')
        }
        const words = cleanedPhrase.split(' ')

        // pour séparer la phrase
        // const words = phrase
        //     .toLowerCase()
        //     .replaceAll(',', '')
        //     .replaceAll('!', '')
        //     .replaceAll(':', '')
        //     .replaceAll('?', '')
        //     .replaceAll('«', '')
        //     .replaceAll('»', '')
        //     .replaceAll('.', '')
        //     .replaceAll('...', '')
        //     .split(' ');
        // console.log(words);

        // on boucle sur chacun des mots de la liste pour les ajouter à l'objet frequencies
        for(let word of words) {
            if(word !== '' && word.length >= 4) {
                if(frequencies[word]) {
                    frequencies[word]++;
                } else {
                    frequencies[word] = 1;
                }
            }
        }

        const frequenciesArray = [];
        for(key in frequencies) {
            frequenciesArray.push({
                word: key,
                count: frequencies[key]
            })
        }
        //console.log(frequencies)
        frequenciesArray.sort((a, b) => b.count - a.count)
        console.log(frequenciesArray)
        console.log(`Les mots les plus fréquents sont :
        1: "${frequenciesArray[0].word}", avec un nombre de ${frequenciesArray[0].count},
        2: "${frequenciesArray[1].word}", avec un nombre de ${frequenciesArray[1].count},
        3: "${frequenciesArray[2].word}", avec un nombre de ${frequenciesArray[2].count}`)

        // split = découper la phrase en fonction d'espace
        // {vous: 3, moi: 2} créer un objet qui contient les fréquences
        // replace = pour retirer les caractères spéciaux
        // les 3 mots qui apparaissent le plus souvent



    </script>
</body>
</html>